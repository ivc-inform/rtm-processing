topology {
  node-id = 1
  seq-cash = 20
}

app {
  // В секундах
  SessionMaxInactiveInterval = 60

  port = 9512
  interface = "localhost"

  isomorphicDir = "isomorphic"
  schemasDir = "/system/schema"

  modulesDir = "/client/modules"
  mainServletPath = "/logic/*"

  //modulesDir = "/system/modules"
  //modulesDir = "/system/modules-debug"
  //skin = "Enterprise"

  classPath4ServletDebug {
    webInfPass = "web-ui/target/webapp/WEB-INF"
  }

  classPath4Servlet = [
    "$web-inf/classes",
    "$web-inf/lib/common-webapp???version???.jar"
  ]
}

LogActor {
  LogHtmlAndJS = debug
  LogHtml = info
  LogJavaScript = info
}

jdbc-journal {
  tables {
    journal {
      tableName = "RTM_PERSISTENCEJOURNAL"
      schemaName = "MOSK"
      columnNames {
        ordering = "NORDERING"
        deleted = "BDELETED"
        persistenceId = "SPERSISTENCE_ID"
        sequenceNumber = "NSEQUENCE_NUMBER"
        created = "NCREATED"
        tags = "STAGS"
        message = "BLBMESSAGE"
      }
    }

    snapshot {
      tableName = "RTM_PERSISTENCESNAPSHOT"
      schemaName = "MOSK"
      columnNames {
        persistenceId = "SPERSISTENCE_ID"
        sequenceNumber = "NSEQUENCE_NUMBER"
        created = "NCREATED"
        snapshot = "BLBSNAPSHOT"
      }
    }
  }

  slick = ${slick}
  slick.db.numThreads = 4
  slick.db.maxConnections = 2
  slick.db.minConnections = 1
}

# the akka-persistence-snapshot-store in use
jdbc-snapshot-store {
  tables {
    snapshot {
      tableName = "RTM_PERSISTENCESNAPSHOT"
      schemaName = "MOSK"
      columnNames {
        persistenceId = "SPERSISTENCE_ID"
        sequenceNumber = "NSEQUENCE_NUMBER"
        created = "NCREATED"
        snapshot = "BLBSNAPSHOT"
      }
    }
  }

  slick = ${slick}
  slick.db.numThreads = 4
  slick.db.maxConnections = 2
  slick.db.minConnections = 1
}

# the akka-persistence-query provider in use
jdbc-read-journal {

  refresh-interval = "100ms"

  max-buffer-size = "500"

  tables {
    journal {
      tableName = "journal"
      schemaName = "MOSK"
    }
  }

  slick = ${slick}
  slick.db.numThreads = 1
  slick.db.maxConnections = 1
  slick.db.minConnections = 1
}

slick {
  driver = "oracle.jdbc.OracleDriver"
  db {
    url = "jdbc:oracle:thin:@orapg.simplesys.lan:1521/test"
    user = "mosk"
    password = "m125osk"
    driver = "oracle.jdbc.OracleDriver"
    connectionTestQuery = "SELECT 1 FROM DUAL"
  }
}

akka {
  loggers = ["com.simplesys.messages.event.Slf4jLogger"]
  //loggers = ["akka.event.slf4j.Slf4jLogger"]
  loglevel = debug
  stdout-loglevel = error
  ask-timeout = 240

  //extensions = ["com.romix.akka.serialization.kryo.KryoSerializationExtension$"]

  actor {

    debug {
      receive = off
      autoreceive = off
      lifecycle = off
      fsm = off
      unhandled = on
    }

    deployment {
      /phoneHolder {

        router = consistent-hashing-pool

        nr-of-instances = 10
        virtual-nodes-factor = 10

        pool-dispatcher {
          type = PinnedDispatcher
          executor = "thread-pool-executor"
          //throughput = 1
          max-pool-size-min = 10
          max-pool-size-max = 10

        }
      }

      "/stageCoordinator/*" {
        dispatcher = processing-core-dispatcher
      }

      "/packCoordinator/*" {
        dispatcher = processing-core-dispatcher
      }

      "/templaterCoordinator/*" {
        dispatcher = processing-core-dispatcher
      }


      /dictionary {
        dispatcher = processing-core-dispatcher
      }

      /packCoordinator {
        dispatcher = processing-core-dispatcher
      }

      /stageCoordinator {
        dispatcher = processing-core-dispatcher
      }
    }

    serializers {
      //myKryo = "com.simplesys.actors.serialization.kryo.KryoSerializer"
      //      kryo = "com.twitter.chill.akka.AkkaSerializer"

      java = "akka.serialization.JavaSerializer"
      //romixKryo = "com.romix.akka.serialization.kryo.KryoSerializer"
      myUPicle = "akka.persistence.upickle.MyAkkaUpickle"
    }

    serialization-bindings {
      "java.io.Serializable" = java
      //"java.io.Serializable" = myKryo

      "akka.persistence.serialization.Snapshot" = myUPicle
      //"akka.persistence.serialization.Snapshot" = myKryo
      //"akka.persistence.serialization.Snapshot" = romixKryo
      //akka-persistence-snapshot
      "akka.persistence.serialization.Message" = myUPicle
      //"akka.persistence.serialization.Message" = myKryo
      //"akka.persistence.serialization.Message" = romixKryo
      //akka-persistence-message
    }

    kryo {
      # Possibles values for type are: graph or nograph
      # graph supports serialization of object graphs with shared nodes
      # and cyclic references, but this comes at the expense of a small
      # overhead nograph does not support object grpahs with shared nodes,
      # but is usually faster
      type = "graph"

      # Possible values for idstrategy are:
      # default, explicit, incremental
      #
      # default - slowest and produces bigger serialized representation.
      # Contains fully-qualified class names (FQCNs) for each class. Note
      # that selecting this strategy does not work in version 0.3.2, but
      # is available on master and from 0.3.3 onward.
      #
      # explicit - fast and produces compact serialized representation.
      # Requires that all classes that will be serialized are pre-registered
      # using the "mappings" and "classes" sections. To guarantee that both
      # sender and receiver use the same numeric ids for the same classes it
      # is advised to provide exactly the same entries in the "mappings"
      # section.
      #
      # incremental - fast and produces compact serialized representation.
      # Support optional pre-registering of classes using the "mappings"
      # and "classes" sections. If class is not pre-registered, it will be
      # registered dynamically by picking a next available id To guarantee
      # that both sender and receiver use the same numeric ids for the same
      # classes it is advised to pre-register them using at least the "classes" section.

      //idstrategy = "incremental"
      //idstrategy = "explicit"
      idstrategy = "default"

      # Define a default size for serializer pool
      # Try to define the size to be at least as big as the max possible
      # number of threads that may be used for serialization, i.e. max
      # number of threads allowed for the scheduler
      serializer-pool-size = 16

      # Define a default size for byte buffers used during serialization
      buffer-size = 4096

      # The serialization byte buffers are doubled as needed until they
      # exceed max-buffer-size and an exception is thrown. Can be -1
      # for no maximum.
      max-buffer-size = -1

      # If set, akka uses manifests to put a class name
      # of the top-level object into each message
      use-manifests = false

      # The transformations that have be done while serialization
      # Supported transformations: compression and encryption
      # accepted values(comma separated if multiple): off | lz4 | deflate | aes
      # Transformations occur in the order they are specified
      //      post-serialization-transformations = "lz4,aes"
      post-serialization-transformations = "lz4"

      # Settings for aes encryption, if included in transformations AES
      # algo mode, key and custom key class can be specified AES algo mode
      # defaults to 'AES/CBC/PKCS5Padding' and key to 'ThisIsASecretKey'.
      # If custom key class is provided, Kryo will use the class specified
      # by a fully qualified class name to get custom AES key. Such a
      # class should define the method 'kryoAESKey'. This key overrides 'key'.
      # If class doesn't contain 'kryoAESKey' method, specified key is used.
      # If this is not present, default key is used
      encryption {
        aes {
          mode = "AES/CBC/PKCS5Padding"
          key = j68KkRjq21ykRGAQ
          //custom-key-class = "CustomAESKeyClass"
        }
      }

      # Log implicitly registered classes. Useful, if you want to know all
      # classes which are serialized. You can then use this information in
      # the mappings and/or classes sections
      implicit-registration-logging = true

      # If enabled, Kryo logs a lot of information about serialization process.
      # Useful for debugging and lowl-level tweaking
      kryo-trace = false

      # If enabled, Kryo uses internally a map detecting shared nodes.
      # This is a preferred mode for big object graphs with a lot of nodes.
      # For small object graphs (e.g. below 10 nodes) set it to false for
      # better performance.
      kryo-reference-map = true

      # If proviced, Kryo uses the class specified by a fully qualified
      # class name to perform a custom initialization of Kryo instances in
      # addition to what is done automatically based on the config file.
      kryo-custom-serializer-init = "com.simplesys.actors.serialization.kryo.KryoSerializerInit"

      # Define mappings from a fully qualified class name to a numeric id.
      # Smaller ids lead to smaller sizes of serialized representations.
      #
      # This section is mandatory for idstartegy=explicit
      # This section is optional  for idstartegy=incremental
      # This section is ignored   for idstartegy=default
      #
      # The smallest possible id should start at 20 (or even higher), because
      # ids below it are used by Kryo internally e.g. for built-in Java and
      # Scala types

      mappings {}

      # Define a set of fully qualified class names for
      # classes to be used for serialization.
      # The ids for those classes will be assigned automatically,
      # but respecting the order of declaration in this section
      #
      # This section is optional  for idstartegy=incremental
      # This section is ignored   for idstartegy=default
      # This section is optional  for idstartegy=explicit
      # If enabled, allows Kryo to resolve subclasses of registered Types.
      #
      # This is primarily useful when idstrategy is set to "explicit". In this
      # case, all classes to be serialized must be explicitly registered. The
      # problem is that a large number of common Scala and Akka types (such as
      # Map and ActorRef) are actually traits that mask a large number of
      # specialized classes that deal with various situations and optimizations.
      # It isn't straightforward to register all of these, so you can instead
      # register a single supertype, with a serializer that can handle *all* of
      # the subclasses, and the subclasses get serialized with that.
      #
      # Use this with care: you should only rely on this when you are confident
      # that the superclass serializer covers all of the special cases properly.
      resolve-subclasses = false

      classes = []
    }
  }

  persistence {

    journal.plugin = "inner-journal"
    snapshot-store.plugin = "inner-snapshot-store"

    //    journal {
    //      plugin = "jdbc-journal"
    //      auto-start-journals = ["jdbc-journal"]
    //    }
    //
    //    snapshot-store {
    //      plugin = "jdbc-snapshot-store"
    //      auto-start-snapshot-stores = ["jdbc-snapshot-store"]
    //    }

    circuit-breaker {
      max-failures = 10
      call-timeout = 40s
      reset-timeout = 60s
    }

    //        journal.plugin = "akka.persistence.journal.leveldb"
    //        journal.leveldb.native = off

    //        journal.plugin = "cassandra-journal"
    //        snapshot-store.plugin = "cassandra-snapshot-store"

    // journal.max-message-batch-size = 1
    //journal.plugin = "bdb-journal"
    # journal.leveldb.native = off
    // journal.plugin = "stub-journal"
    //snapshots are good file-based store
    //snapshot-store.plugin = "stub-snapshot-store"
  }

  http {
    log-http-config-on-init = off
    system-name = rtm-processing
    timeout = 0
    expired-header-name = wtf
    expired-header-value = wtf2
  }

}

processing-core-dispatcher {
  //  type = PinnedDispatcher
  //  executor = "thread-pool-executor"
  throughput = 2
  //  max-pool-size-min = 3
}

messaging {

  # how often do we send keepalives to the client (ms)
  #deprecated
  keepaliveInterval = 3000

  #deprecated
  clientReconnectWindow = 10000

  # how long the client waits after the keepaliveInterval before re-establishing
  # the connection (ms)
  #deprecated
  keepaliveReestablishDelay = 1000

  # how long the client waits for the connect handshake to complete before
  # retrying
  connectTimeout = 500

  # connection time to live - the maximum amount of time a persistent connection
  # is allowed to stay open before being re-established (ms)
  connectionTTL = 60000

  # total response size to pad out to in order to defeat intervening
  # bufferring by proxies (bytes)
  #deprecated
  flushBufferSize = 8096
}

rtm-processing {

  fakeSMSSendMode = false
  fakeSMSSendModePhone = "76666666666"

  sequenceCache = 1000

  logger {
    writersCount = 2
    retryPeriod = 10 //sec
  }

  common {
    actor-system-name = "rtm-processing"
  }

  smsSender {
    address = "gatetest.mfms.ru:8123/connector/base/hpg/send"
    login = "test"
    password = "test"
    subject = "900"
    passwordParamName = "pass"

    //    address = "10.34.1.131:9574/sb/connector10/send"
    //    login = "sb10"
    //    password = "qAtXuJb8"
    //    subject = "900"
    //    passwordParamName = "password"

    responseTimeout = 5s
    passwordParamName = "pass"
  }

  test {
    host = "127.0.0.1"
    port = 40000
    serviceName = "ComfmdiMfmdMfmdOutMessageService"
  }

  stub {
    host = "127.0.0.1"
    port = 40000
    serviceName = "ComfmdiMfmdMfmdOutMessageService"
  }

  prod {
    host = "127.0.0.1"
    port = 40000
    serviceName = "ComfmdiMfmdMfmdOutMessageService"
  }

  similarTerminalCache {
    replaceToWhitespaceRegexp = "[^a-zA-Z\\s]"
    tokenizeRegexp = "[-_:\\s]+"
    minimumTerminalNameLength = 8
    forkJoinThreadCount = 4
    minimumSimilarityMerchantUnitMetricValue = 1.0
    minimumSimilarityCategoryMetricValue = 0.9
  }

  classifier {
    modelName = "word2vec"
    clusterCount = 20
    dimensions = 300
  }

  templates {
    exampleRecordCount = 10
    templatesPath = "fixed_sb.save.xml"
    //templatesPath = "fixed_raiff.save.xml"
  }

  actors {
    pathToFullSave = backups/actors-full
    pathToShortSave = backups/actors-short
    pathToExport = backups/actors-export

    snapshotEvery = 1h
    fullSaveToFileEvery = 4h
    shortSaveToFileEvery = 20m
  }
}

dbPool {
  defaultAdvisa = "db-connection-stack.oracleMFMSAdvisa"
  defaultSave = "db-connection-stack.oracleMFMSSave"
  defaultLogging = "db-connection-stack.oracleMFMSLogging"
  defaultScenario = "db-connection-stack.oracleMFMSScenario"
}

db-connection-stack {
  oracleMFMSAdvisa {
    oraclcePoolDataSource {
      className = "oracle.jdbc.pool.OracleDataSource"

      //url = "jdbc:oracle:thin:@//10.34.0.12:1521/MBVMFMS"
      //user = MFMDATAAPP
      //password = "mfmdataapp+-26"

      url = "jdbc:oracle:thin:@//orapg.simplesys.lan:1521/test"
      user = mfms_advisa_prod
      password = mfms_advisa_prod
      initialSize = 1
      fetchSize = 1000
      timeZone = "Europe/Moscow"
    }
  }

  oracleMFMSSave {
      oraclcePoolDataSource {
        className = "oracle.jdbc.pool.OracleDataSource"

        //url = "jdbc:oracle:thin:@//10.34.0.5:1521/mstat"
        //user = DMPROD_SAVE
        //password = "ktd_njkcnjq"

        url = "jdbc:oracle:thin:@//orapg.simplesys.lan:1521/test"
        user = mosk
        password = m125osk
        initialSize = 1
        fetchSize = 1000
        timeZone = "Europe/Moscow"
      }
    }

  oracleMFMSLogging {
    oraclcePoolDataSource {
      className = "oracle.jdbc.pool.OracleDataSource"

      //url = "jdbc:oracle:thin:@//10.34.0.5:1521/mstat"
      //user = DMPROD_SAVE
      //password = "ktd_njkcnjq"

      url = "jdbc:oracle:thin:@//orapg.simplesys.lan:1521/test"
      user = mosk
      password = m125osk
      initialSize = 1
      fetchSize = 1000
      timeZone = "Europe/Moscow"
    }
   }

  oracleMFMSScenario {
      oraclcePoolDataSource {
        className = "oracle.jdbc.pool.OracleDataSource"

        //url = "jdbc:oracle:thin:@//10.34.0.5:1521/mstat"
        //user = DMPROD_SAVE
        //password = "ktd_njkcnjq"

        url = "jdbc:oracle:thin:@//orapg.simplesys.lan:1521/test"
        user = mosk
        password = m125osk
        initialSize = 1
        fetchSize = 1000
        timeZone = "Europe/Moscow"
      }
    }
}
